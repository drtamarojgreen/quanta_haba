# Quanta Haba & TissLM Integration Demo

This document outlines the design for a demo editor application, `quanta_haba`, which integrates with the `quanta_tissu` language model package to automate a task-based workflow.

## 1. Dependencies

The application requires the `quanta_tissu` package to be installed in an editable mode directly from its Git repository. This is specified in the `requirements.txt` file:

```
-e git+https://github.com/drtamarojgreen/quanta_tissu
```

This setup ensures that `import quanta_tissu` is resolved correctly within the `quanta_haba` environment.

## 2. Editor Layout (Tkinter)

The user interface is built with Tkinter and divided into three main panels:

-   **Left Panel (Prompt Editor)**: A `Text` widget that loads a prompt file upon startup. Instead of being blank, it will be pre-populated with the contents of `default_prompt.txt`, which contains a series of tasks prefixed with `TODO:`.

-   **Right Panel (Dashboard View)**: A `Text` or `Frame` widget. This panel displays a clean, high-level summary of completed tasks and the corresponding results generated by the language model.

-   **Bottom Panel (Console Log)**: A `Text` widget that provides a verbose, raw log of the entire process. It will show the exact prompts sent to the model, the full responses received, and any subsequent actions taken by the integrated toolkit.

## 3. Workflow Behavior

The application follows an automated, step-by-step execution loop:

1.  **Initialization**: On launch, the application loads `default_prompt.txt` into the left panel.
2.  **Task Identification**: The application identifies the first line containing a `TODO:` task and highlights it.
3.  **Model Invocation**: The content of the highlighted `TODO:` line is extracted and sent to the language model using the `quanta_tissu` package:
    ```python
    from quanta_tissu import generate
    response = generate(task_line)
    ```
4.  **Toolkit Processing**: The raw `response` from the model is passed to a (currently stubbed) toolkit for further processing.
    ```python
    # Stubbed toolkit function
    toolkit_result = f"Toolkit processed: {response}"
    ```
5.  **Logging**: The original prompt, the model's response, and the toolkit's result are all logged to the bottom console panel.
6.  **Dashboard Update**: A summary entry is added to the right dashboard panel, formatted as: `✓ TODO_ITEM → Model Response`.
7.  **State Update**: In the left panel, the `TODO:` prefix on the processed line is changed to `DONE:`.
8.  **Iteration**: The application automatically highlights the next unfinished `TODO:` task and repeats the cycle until no `TODO:` tasks remain.

## 4. Demo Flow Example

This section illustrates the user experience from start to finish.

**Initial State:**

-   A file named `default_prompt.txt` exists with the following content:
    ```
    TODO: Generate project title
    TODO: Suggest 3 features
    TODO: Write short summary
    ```

**Execution Steps:**

1.  **Launch**: The application starts. The left panel displays the content of `default_prompt.txt`. The line `TODO: Generate project title` is highlighted.
2.  **First Task**:
    -   The prompt "Generate project title" is sent to the model.
    -   Let's say the model responds with "Project Quanta".
    -   **Console Log** shows the prompt, the "Project Quanta" response, and the toolkit action.
    -   **Dashboard** displays: `✓ Generate project title → Project Quanta`.
    -   **Left Panel** updates the line to: `DONE: Generate project title`.
    -   The highlight moves to `TODO: Suggest 3 features`.
3.  **Second Task**:
    -   The process repeats for "Suggest 3 features".
    -   The dashboard is updated with the new result.
    -   The left panel is updated to `DONE:`.
    -   The highlight moves to the final `TODO`.
4.  **Conclusion**: The demo runs until all `TODO:` items are marked as `DONE:`, visually demonstrating the automated, step-by-step resolution of a task list driven by the language model.
